<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Sorting Visualizer – Srujan Yamali</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root {
            --bg: #050816;
            --panel: #0f172a;
            --accent: #38bdf8;
            --accent-soft: rgba(56, 189, 248, 0.15);
            --text: #e5e7eb;
            --muted: #9ca3af;
            --danger: #f97373;
            --radius-lg: 16px;
            --radius-full: 999px;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            min-height: 100vh;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
            sans-serif;
            background: radial-gradient(circle at top, #1f2937 0, #020617 45%, #000 100%);
            color: var(--text);
            display: flex;
            align-items: stretch;
            justify-content: center;
            padding: 24px;
        }

        .app {
            width: 100%;
            max-width: 1120px;
            margin: auto;
            display: grid;
            grid-template-columns: 2.2fr 1.2fr;
            gap: 24px;
        }

        @media (max-width: 900px) {
            .app {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: linear-gradient(145deg, #020617 0, #0b1120 50%, #020617 100%);
            border-radius: var(--radius-lg);
            border: 1px solid rgba(148, 163, 184, 0.22);
            box-shadow: 0 20px 40px rgba(15, 23, 42, 0.9);
            padding: 20px 20px 16px;
            backdrop-filter: blur(16px);
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 16px;
        }

        .title-group h1 {
            font-size: 1.35rem;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .title-pill {
            font-size: 0.7rem;
            padding: 2px 10px;
            border-radius: var(--radius-full);
            border: 1px solid rgba(56, 189, 248, 0.4);
            background: rgba(15, 23, 42, 0.9);
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .subtitle {
            margin: 4px 0 0;
            font-size: 0.8rem;
            color: var(--muted);
        }

        .pill-badge {
            font-size: 0.72rem;
            padding: 6px 10px;
            border-radius: var(--radius-full);
            background: rgba(22, 163, 74, 0.1);
            border: 1px solid rgba(34, 197, 94, 0.4);
            color: #bbf7d0;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }

        .pill-dot {
            width: 8px;
            height: 8px;
            border-radius: 999px;
            background: #22c55e;
            box-shadow: 0 0 12px rgba(34, 197, 94, 0.8);
        }

        .controls-row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .select {
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        select {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            padding: 7px 28px 7px 10px;
            border-radius: var(--radius-full);
            border: 1px solid rgba(148, 163, 184, 0.4);
            background: rgba(15, 23, 42, 0.95);
            color: var(--text);
            font-size: 0.82rem;
            cursor: pointer;
        }

        .select::after {
            content: "▾";
            position: absolute;
            right: 10px;
            font-size: 0.6rem;
            color: var(--muted);
            pointer-events: none;
        }

        button {
            border: none;
            border-radius: var(--radius-full);
            font-size: 0.82rem;
            padding: 7px 12px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: radial-gradient(circle at top left, #38bdf8, #0ea5e9 55%, #0369a1);
            color: #0b1120;
            font-weight: 500;
            box-shadow: 0 10px 22px rgba(56, 189, 248, 0.35);
            transition: transform 0.1s ease, box-shadow 0.1s ease, filter 0.1s ease;
        }

        button.secondary {
            background: rgba(15, 23, 42, 0.95);
            color: var(--text);
            border: 1px solid rgba(148, 163, 184, 0.4);
            box-shadow: none;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        button:not(:disabled):hover {
            transform: translateY(-1px);
            filter: brightness(1.05);
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.74rem;
            color: var(--muted);
            flex: 1;
            min-width: 180px;
        }

        .slider-group label {
            white-space: nowrap;
        }

        input[type="range"] {
            flex: 1;
            accent-color: var(--accent);
        }

        .tags-row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
            font-size: 0.7rem;
            color: var(--muted);
            margin-bottom: 6px;
        }

        .tag {
            padding: 2px 8px;
            border-radius: var(--radius-full);
            border: 1px solid rgba(148, 163, 184, 0.35);
            background: rgba(15, 23, 42, 0.9);
        }

        .metrics-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 0.7rem;
            color: var(--muted);
            margin-bottom: 10px;
        }

        .metric {
            padding: 4px 8px;
            border-radius: var(--radius-full);
            background: rgba(15, 23, 42, 0.9);
            border: 1px dashed rgba(148, 163, 184, 0.4);
        }

        #visualizationContainer {
            position: relative;
            height: 320px;
            padding: 10px;
            border-radius: 14px;
            background: radial-gradient(circle at top left, #1f2937, #020617 60%, #000);
            border: 1px solid rgba(31, 41, 55, 0.8);
            overflow: hidden;
        }

        #bars {
            position: absolute;
            inset: 16px 8px 10px;
            display: flex;
            align-items: flex-end;
            gap: 3px;
        }

        .bar {
            flex: 1;
            border-radius: 6px 6px 0 0;
            background: linear-gradient(to top, #0ea5e9, #38bdf8);
            box-shadow: 0 6px 14px rgba(56, 189, 248, 0.45);
            transition: transform 0.08s linear, height 0.08s linear,
            background 0.08s linear, box-shadow 0.08s linear;
        }

        .bar.compare {
            background: linear-gradient(to top, #facc15, #fde047);
            box-shadow: 0 6px 14px rgba(234, 179, 8, 0.55);
        }

        .bar.swap {
            background: linear-gradient(to top, #f97373, #fecaca);
            box-shadow: 0 6px 14px rgba(248, 113, 113, 0.65);
            transform: translateY(-4px);
        }

        .bar.sorted {
            background: linear-gradient(to top, #22c55e, #bbf7d0);
            box-shadow: 0 6px 14px rgba(34, 197, 94, 0.65);
        }

        .watermark {
            position: absolute;
            bottom: 10px;
            right: 16px;
            font-size: 0.7rem;
            color: rgba(148, 163, 184, 0.55);
            pointer-events: none;
        }

        .side-panel-title {
            font-size: 0.95rem;
            margin: 0 0 6px;
        }

        .algo-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 0.76rem;
            padding: 4px 9px;
            border-radius: var(--radius-full);
            border: 1px solid rgba(56, 189, 248, 0.4);
            background: rgba(15, 23, 42, 0.9);
            margin-bottom: 6px;
        }

        .algo-badge-dot {
            width: 8px;
            height: 8px;
            border-radius: 999px;
            background: var(--accent);
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.9);
        }

        .algo-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            font-size: 0.72rem;
            color: var(--muted);
            margin: 8px 0 10px;
        }

        .algo-meta span {
            padding: 2px 8px;
            border-radius: var(--radius-full);
            border: 1px dashed rgba(148, 163, 184, 0.4);
        }

        .algo-description {
            font-size: 0.78rem;
            color: var(--muted);
            line-height: 1.4;
            margin-bottom: 10px;
        }

        .code-block {
            font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo,
            Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.7rem;
            background: #020617;
            border-radius: 10px;
            padding: 8px 10px;
            border: 1px solid rgba(15, 23, 42, 0.9);
            color: #e5e7eb;
            max-height: 170px;
            overflow: auto;
            white-space: pre;
        }

        .hint {
            margin-top: 6px;
            font-size: 0.7rem;
            color: var(--muted);
        }

        .hint strong {
            color: var(--accent);
            font-weight: 500;
        }
    </style>
</head>
<body>
<div class="app">
    <!-- Main visualizer -->
    <div class="card">
        <div class="header">
            <div class="title-group">
                <h1>
                    Sorting Visualizer
                    <span class="title-pill">sort.srujanyamali.com</span>
                </h1>
                <p class="subtitle">
                    Watch classic sorting algorithms reorder an array in real-time.
                </p>
            </div>
            <div class="pill-badge">
                <span class="pill-dot"></span>
                Interactive demo
            </div>
        </div>

        <div class="controls-row">
            <div class="select">
                <select id="algorithmSelect">
                    <option value="bubble">Bubble Sort</option>
                    <option value="selection">Selection Sort</option>
                    <option value="insertion">Insertion Sort</option>
                    <option value="merge">Merge Sort</option>
                    <option value="quick">Quick Sort</option>
                </select>
            </div>

            <button id="playPauseBtn">
                ▶ Start
            </button>

            <button id="newArrayBtn" class="secondary">
                ⟳ New Array
            </button>
        </div>

        <div class="controls-row">
            <div class="slider-group">
                <label for="sizeRange">Size</label>
                <input type="range" id="sizeRange" min="10" max="120" value="60" />
            </div>
            <div class="slider-group">
                <label for="speedRange">Speed</label>
                <input type="range" id="speedRange" min="1" max="60" value="32" />
            </div>
        </div>

        <div class="tags-row">
            <span class="tag">O(n² to n log n)</span>
            <span class="tag">Visual comparisons & swaps</span>
            <span class="tag">Stable vs. unstable</span>
        </div>

        <div class="metrics-row">
            <div class="metric" id="metricComparisons">Comparisons: 0</div>
            <div class="metric" id="metricSwaps">Writes: 0</div>
            <div class="metric" id="metricStatus">Status: idle</div>
        </div>

        <div id="visualizationContainer">
            <div id="bars"></div>
            <div class="watermark">srujanyamali · sorting</div>
        </div>
    </div>

    <!-- Side panel: explanation -->
    <div class="card">
        <div class="side-panel-header">
            <p class="side-panel-title">Algorithm details</p>
            <div class="algo-badge" id="algoNameBadge">
                <span class="algo-badge-dot"></span>
                Bubble Sort
            </div>
        </div>

        <div class="algo-meta" id="algoMeta">
            <!-- filled by JS -->
        </div>

        <p class="algo-description" id="algoDescription">
            Bubble sort repeatedly walks through the array, comparing adjacent
            elements and swapping them if they are in the wrong order. Large values
            "bubble" to the end of the array on each pass.
        </p>

        <div class="code-block" id="algoPseudocode">
            bubbleSort(a):
            n = length(a)
            repeat
            swapped = false
            for i from 0 to n - 2:
            if a[i] > a[i+1]:
            swap a[i], a[i+1]
            swapped = true
            until not swapped
        </div>

        <p class="hint">
            Tip: drag <strong>Size</strong> to the right for more bars or slide
            <strong>Speed</strong> to tune the animation.
        </p>
    </div>
</div>

<script>
    // ---------- State ----------
    let array = [];
    let isSorting = false;
    let shouldStop = false;
    let speedMs = 40;
    let comparisons = 0;
    let writes = 0;

    const barsEl = document.getElementById("bars");
    const algorithmSelect = document.getElementById("algorithmSelect");
    const sizeRange = document.getElementById("sizeRange");
    const speedRange = document.getElementById("speedRange");
    const playPauseBtn = document.getElementById("playPauseBtn");
    const newArrayBtn = document.getElementById("newArrayBtn");
    const metricComparisons = document.getElementById("metricComparisons");
    const metricSwaps = document.getElementById("metricSwaps");
    const metricStatus = document.getElementById("metricStatus");
    const algoNameBadge = document.getElementById("algoNameBadge");
    const algoMeta = document.getElementById("algoMeta");
    const algoDescription = document.getElementById("algoDescription");
    const algoPseudocode = document.getElementById("algoPseudocode");

    const algoInfo = {
        bubble: {
            name: "Bubble Sort",
            time: "O(n²)",
            space: "O(1)",
            stable: "Stable",
            description:
                "Bubble sort repeatedly scans the array, swapping adjacent elements that are out of order. Large values move to the end with each pass, like bubbles rising in water.",
            pseudocode: `bubbleSort(a):
  n = length(a)
  repeat
    swapped = false
    for i from 0 to n - 2:
      if a[i] > a[i+1]:
        swap a[i], a[i+1]
        swapped = true
  until not swapped`,
        },
        selection: {
            name: "Selection Sort",
            time: "O(n²)",
            space: "O(1)",
            stable: "Unstable",
            description:
                "Selection sort repeatedly selects the smallest remaining element and swaps it into the next position. It minimizes writes but still does O(n²) comparisons.",
            pseudocode: `selectionSort(a):
  n = length(a)
  for i from 0 to n - 2:
    minIndex = i
    for j from i+1 to n - 1:
      if a[j] < a[minIndex]:
        minIndex = j
    swap a[i], a[minIndex]`,
        },
        insertion: {
            name: "Insertion Sort",
            time: "O(n²) (best: O(n))",
            space: "O(1)",
            stable: "Stable",
            description:
                "Insertion sort builds a sorted prefix one element at a time. Each new element is inserted into its correct spot within the already sorted part of the array.",
            pseudocode: `insertionSort(a):
  n = length(a)
  for i from 1 to n - 1:
    key = a[i]
    j = i - 1
    while j >= 0 and a[j] > key:
      a[j+1] = a[j]
      j = j - 1
    a[j+1] = key`,
        },
        merge: {
            name: "Merge Sort",
            time: "O(n log n)",
            space: "O(n)",
            stable: "Stable",
            description:
                "Merge sort uses divide-and-conquer: it recursively splits the array, sorts each half, then merges the sorted halves back together.",
            pseudocode: `mergeSort(a):
  if length(a) ≤ 1:
    return a
  mid = length(a) / 2
  left  = mergeSort(a[0..mid-1])
  right = mergeSort(a[mid..end])
  return merge(left, right)`,
        },
        quick: {
            name: "Quick Sort",
            time: "O(n log n) average",
            space: "O(log n) stack",
            stable: "Unstable",
            description:
                "Quick sort chooses a pivot, partitions the array into elements less than and greater than the pivot, then recursively sorts each side. Very fast in practice.",
            pseudocode: `quickSort(a, lo, hi):
  if lo < hi:
    p = partition(a, lo, hi)
    quickSort(a, lo, p - 1)
    quickSort(a, p + 1, hi)`,
        },
    };

    function updateAlgoPanel() {
        const key = algorithmSelect.value;
        const info = algoInfo[key];
        algoNameBadge.innerHTML = `
        <span class="algo-badge-dot"></span>
        ${info.name}
      `;
        algoMeta.innerHTML = `
        <span>Time: ${info.time}</span>
        <span>Space: ${info.space}</span>
        <span>${info.stable}</span>
      `;
        algoDescription.textContent = info.description;
        algoPseudocode.textContent = info.pseudocode;
    }

    // ---------- Utilities ----------
    function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }

    function resetMetrics() {
        comparisons = 0;
        writes = 0;
        metricComparisons.textContent = "Comparisons: 0";
        metricSwaps.textContent = "Writes: 0";
    }

    function updateComparisons(delta = 1) {
        comparisons += delta;
        metricComparisons.textContent = "Comparisons: " + comparisons;
    }

    function updateWrites(delta = 1) {
        writes += delta;
        metricSwaps.textContent = "Writes: " + writes;
    }

    function setStatus(text) {
        metricStatus.textContent = "Status: " + text;
    }

    function generateArray() {
        const size = parseInt(sizeRange.value, 10);
        array = [];
        for (let i = 0; i < size; i++) {
            array.push(Math.random());
        }
        resetMetrics();
        renderArray();
        setStatus("idle");
    }

    function renderArray(highlight = {}) {
        const { compare = [], swap = [], sorted = [] } = highlight;
        const n = array.length;
        barsEl.innerHTML = "";
        for (let i = 0; i < n; i++) {
            const bar = document.createElement("div");
            bar.classList.add("bar");
            const heightPct = 10 + array[i] * 90;
            bar.style.height = heightPct + "%";

            if (compare.includes(i)) bar.classList.add("compare");
            if (swap.includes(i)) bar.classList.add("swap");
            if (sorted.includes(i)) bar.classList.add("sorted");

            barsEl.appendChild(bar);
        }
    }

    function onSpeedChange() {
        const v = parseInt(speedRange.value, 10);
        // Map 1–60 slider to ~10–120ms delay
        const maxDelay = 120;
        const minDelay = 10;
        const factor = 1 - v / 60;
        speedMs = minDelay + factor * (maxDelay - minDelay);
    }

    // ---------- Algorithms with visualization ----------
    async function bubbleSort() {
        const n = array.length;
        for (let i = 0; i < n - 1; i++) {
            if (shouldStop) return;
            let swapped = false;
            for (let j = 0; j < n - 1 - i; j++) {
                if (shouldStop) return;
                updateComparisons();
                renderArray({ compare: [j, j + 1] });
                await sleep(speedMs);
                if (array[j] > array[j + 1]) {
                    [array[j], array[j + 1]] = [array[j + 1], array[j]];
                    updateWrites(2);
                    renderArray({ swap: [j, j + 1] });
                    await sleep(speedMs);
                    swapped = true;
                }
            }
            renderArray({ sorted: Array.from({ length: n }, (_, idx) => idx >= n - 1 - i ? idx : -1).filter(i => i >= 0) });
            if (!swapped) break;
        }
    }

    async function selectionSort() {
        const n = array.length;
        for (let i = 0; i < n - 1; i++) {
            if (shouldStop) return;
            let minIndex = i;
            for (let j = i + 1; j < n; j++) {
                if (shouldStop) return;
                updateComparisons();
                renderArray({ compare: [minIndex, j] });
                await sleep(speedMs);
                if (array[j] < array[minIndex]) {
                    minIndex = j;
                }
            }
            if (minIndex !== i) {
                [array[i], array[minIndex]] = [array[minIndex], array[i]];
                updateWrites(2);
            }
            renderArray({ swap: [i, minIndex] });
            await sleep(speedMs);
        }
        renderArray({ sorted: array.map((_, i) => i) });
    }

    async function insertionSort() {
        const n = array.length;
        for (let i = 1; i < n; i++) {
            if (shouldStop) return;
            let key = array[i];
            let j = i - 1;
            while (j >= 0) {
                updateComparisons();
                renderArray({ compare: [j, j + 1] });
                await sleep(speedMs);
                if (array[j] > key) {
                    array[j + 1] = array[j];
                    updateWrites();
                    j--;
                    renderArray({ swap: [j + 1] });
                    await sleep(speedMs);
                } else {
                    break;
                }
                if (shouldStop) return;
            }
            array[j + 1] = key;
            updateWrites();
            renderArray({ swap: [j + 1] });
            await sleep(speedMs);
        }
        renderArray({ sorted: array.map((_, i) => i) });
    }

    async function mergeSortWrapper() {
        await mergeSort(0, array.length - 1);
        renderArray({ sorted: array.map((_, i) => i) });
    }

    async function mergeSort(l, r) {
        if (l >= r || shouldStop) return;
        const m = Math.floor((l + r) / 2);
        await mergeSort(l, m);
        await mergeSort(m + 1, r);
        await merge(l, m, r);
    }

    async function merge(l, m, r) {
        const left = array.slice(l, m + 1);
        const right = array.slice(m + 1, r + 1);
        let i = 0,
            j = 0,
            k = l;
        while (i < left.length && j < right.length) {
            if (shouldStop) return;
            updateComparisons();
            const idxs = [k];
            renderArray({ compare: idxs });
            await sleep(speedMs);
            if (left[i] <= right[j]) {
                array[k] = left[i++];
            } else {
                array[k] = right[j++];
            }
            updateWrites();
            renderArray({ swap: [k] });
            await sleep(speedMs);
            k++;
        }
        while (i < left.length) {
            if (shouldStop) return;
            array[k] = left[i++];
            updateWrites();
            renderArray({ swap: [k] });
            await sleep(speedMs);
            k++;
        }
        while (j < right.length) {
            if (shouldStop) return;
            array[k] = right[j++];
            updateWrites();
            renderArray({ swap: [k] });
            await sleep(speedMs);
            k++;
        }
    }

    async function quickSortWrapper() {
        await quickSort(0, array.length - 1);
        renderArray({ sorted: array.map((_, i) => i) });
    }

    async function quickSort(lo, hi) {
        if (shouldStop || lo >= hi) return;
        const p = await partition(lo, hi);
        await quickSort(lo, p - 1);
        await quickSort(p + 1, hi);
    }

    async function partition(lo, hi) {
        const pivot = array[hi];
        let i = lo;
        for (let j = lo; j < hi; j++) {
            if (shouldStop) return lo;
            updateComparisons();
            renderArray({ compare: [j, hi] });
            await sleep(speedMs);
            if (array[j] < pivot) {
                [array[i], array[j]] = [array[j], array[i]];
                updateWrites(2);
                renderArray({ swap: [i, j] });
                await sleep(speedMs);
                i++;
            }
        }
        [array[i], array[hi]] = [array[hi], array[i]];
        updateWrites(2);
        renderArray({ swap: [i, hi] });
        await sleep(speedMs);
        return i;
    }

    async function runAlgorithm() {
        const algo = algorithmSelect.value;
        resetMetrics();
        setStatus("sorting");
        isSorting = true;
        shouldStop = false;
        playPauseBtn.textContent = "⏸ Pause";
        newArrayBtn.disabled = true;
        algorithmSelect.disabled = true;
        sizeRange.disabled = true;

        switch (algo) {
            case "bubble":
                await bubbleSort();
                break;
            case "selection":
                await selectionSort();
                break;
            case "insertion":
                await insertionSort();
                break;
            case "merge":
                await mergeSortWrapper();
                break;
            case "quick":
                await quickSortWrapper();
                break;
        }

        if (!shouldStop) {
            setStatus("done");
        } else {
            setStatus("paused");
        }

        isSorting = false;
        playPauseBtn.textContent = "▶ Start";
        newArrayBtn.disabled = false;
        algorithmSelect.disabled = false;
        sizeRange.disabled = false;
    }

    // ---------- Event handlers ----------
    playPauseBtn.addEventListener("click", async () => {
        if (!isSorting) {
            shouldStop = false;
            runAlgorithm();
        } else {
            shouldStop = true;
            isSorting = false;
            playPauseBtn.textContent = "▶ Resume";
            setStatus("paused");
            newArrayBtn.disabled = false;
            algorithmSelect.disabled = false;
            sizeRange.disabled = false;
        }
    });

    newArrayBtn.addEventListener("click", () => {
        if (isSorting) return;
        generateArray();
    });

    algorithmSelect.addEventListener("change", () => {
        if (isSorting) return;
        updateAlgoPanel();
    });

    sizeRange.addEventListener("input", () => {
        if (isSorting) return;
        generateArray();
    });

    speedRange.addEventListener("input", () => {
        onSpeedChange();
    });

    // ---------- Init ----------
    onSpeedChange();
    updateAlgoPanel();
    generateArray();
</script>
</body>
</html>
